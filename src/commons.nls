;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fonctions diverses communes aux différents agents ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


; Rotation de l'agent vers sa cible, sans dépasser un angle limite pour garder un certain réalisme
to rotate-agent [ goal ]
  ; Si le drone se trouve à l'endroit souhaité (modulo l'altitude)
  if is-turtle? goal and [xcor] of goal = xcor and [ycor] of goal = ycor or 
  is-patch? goal and [pxcor] of goal = xcor and [pycor] of goal = ycor [
    stop
  ]
  
  ; Calcul de l'angle avec la cible
  let headingFlag (towards-nowrap goal)
  let dirCorrection subtract-headings headingFlag heading
  
  ; Arrondissement de l'angle (on ne veut pas faire de micro tournant)
  set dirCorrection precision dirCorrection 2
  
  ; Limite de l'angle, pour que ce soit plus realiste (l'ennemi ne peut pas faire un demi-tour sur place!)
  ifelse dirCorrection > max-dir [ ; limite a droite
    set dirCorrection max-dir
  ]
  [
    if dirCorrection < max-dir * -1 [ ; limite a gauche
      set dirCorrection max-dir * -1
    ]
  ]
  
  ; On tourne
  rt dirCorrection
end

to-report distance-nowrap-noZAxis [ source target ]
  report [distance-nowrap source] of target - abs ([zcor] of source - [pzcor] of target)
end

;; Revoie un Agentset composé de l'ensemble des convois dans le champ de vision
to-report detect-convois-in-vision
  let targets convois in-radius-nowrap vision-radius
  let retour []
  foreach sort-on [distance myself] targets
  [
    if abs subtract-headings [heading] of ? heading < vision-angle / 2
    [
      set retour lput ? retour
    ]
  ]
  report retour
end

;; Revoie vrai si un agent se trouve sur la trajectoire de deplacement de l'agent
to-report detect-agent-between-target [target]
  let temp 1
  let headingFlag heading - 40
  while [ headingFlag < heading + 40 ]
  [
    while [ temp < distance target ]
    [
      if any? other enemies-on patch-at-heading-and-distance headingFlag temp or any? convois-on patch-at-heading-and-distance headingFlag temp
      [ report true ]
      set temp temp + 1
    ]
    set headingFlag headingFlag + 10
  ]
  
  ; Si on arrive là c'est qu'il n'y avait personne devant
  report false
end

to-report detect-obstacle-between-target [target]
; Vérification qu'on ne va pas dans le vide
  if abs (xcor - [pxcor] of patch-ahead speed) > speed + safe-distance or abs (ycor - [pycor] of patch-ahead speed) > speed + safe-distance
  [ report true ]
  
  let temp speed
  let headingFlag heading - 40
  while [ headingFlag < heading + 40 ]
  [
    while [ temp <= distance target ]
    [
      if [obstacle?] of patch-at-heading-and-distance headingFlag temp [ report true ]
      set temp temp + 1
    ]
    set headingFlag headingFlag + 10
  ]

  ; Si on arrive là c'est qu'on n'avait pas de 
  report false
end

;;;;;;;;;;;;;;;;;;;;
;; Communications ;;
;;;;;;;;;;;;;;;;;;;;

;; Indique si le message est bien celui qu'on attend...
to-report check-message [msg performative content]
  if content = nobody
  [ report msg != nobody and msg != "no_message" and get-performative msg = performative ]
  report msg != nobody and msg != "no_message" and get-performative msg = performative and get-content msg = content
end

;; Crée un message complet à partir des informations fournies
to-report create-complete-msg [receiver performative content]
  let msg create-message performative
  
  ifelse is-list? receiver
  [ set msg add-multiple-receivers receiver msg ]
  [ set msg add-receiver receiver msg ]
  
  set msg add-content content msg
  report msg
end

;; Crée une réponse complète à un message donné grâce aux informations fournies
to-report create-complete-reply [msg performative content]
  let reply create-reply performative msg
  set reply add-content content reply 
  report reply
end

;; Récupère le message seulement si la performative est ce qu'on attend
to-report get-msg-if-performative [performative]
  let msg get-message-no-remove
  if get-performative msg = performative [ report get-message ]
  report nobody
end

;;;;;;;;;;;;;;;;;;;
;; Connaissances ;;
;;;;;;;;;;;;;;;;;;;

;; Structure représentant les connaissances de chaque drones
;; et de chaque convoi concernant leurs alliés
;; ---
;; Liste [Infos-Drones, Infos-Convois]
;; • Info-Drones
;;   Liste [ticks, turtle, position, role, dead?, health, fuel]
;;   o ticks       : Date de l'observation
;;   o turle       : Drone concerné
;;   o position    : Patch où se trouvait le drone
;;   o role        : Role du drone
;;   o dead?       : Etat du drone (vivant / mort)
;;   o health      : Points de vie restants au drone
;;   o fuel        : Carburant restant au drone
;; • Info-Convoi
;;   Liste [ticks, turtle, position, role, dead?, health]
;;   --- Idem, sans le champs "fuel"

;; Fusion de connaissances
to update-knowledges-drones [new-knowledges]
  if get-performative new-knowledges = "knowledge"
  [
    ;; Récupération des connaissances
    let content get-content new-knowledges
    
    ;; Récupération de la liste des croyances sur les drones
    let Infos-Drones K-get "K-Infos-Drones" content
    
    let tick-of-K 0
    
    ;; Pour chaque drone
    foreach Infos-Drones
    [
      let turt K-get "turtle" ?
      set tick-of-K K-get "tick" ?
      
      ;; On ne traite que les drones autres que nous même
      if turt != self [
        
        ;; Récupération de nos croyance concernant ce drone
        let current-info-drone K-get-Info-Drone turt
        
        let K-Infos-Drones intelligent-get-belief "K-Infos-Drones"
        
        ifelse current-info-drone = [] 
        [
          intelligent-update-belief "K-Infos-Drones" lput ? K-Infos-Drones
        ]
        [
          if tick-of-K > K-get "tick" current-info-drone
          [
            let pos position current-info-drone K-Infos-Drones
            intelligent-update-belief "K-Infos-Drones" lput ? remove-item pos K-Infos-Drones
            set K-drones-updated true
          ]
        ]
      ]
    ]
    
    ;; Récupération de la liste des croyances sur les convois
    let Infos-Convois K-get "K-Infos-Convois" content
    
    ;; Pour chaque convoi
    foreach Infos-Convois
    [
      ;; Récupération de nos croyance concernant ce drone
      let current-info-convoi K-get-Info-Convoi K-get "turtle" ?
      
      ;; Vérification de la date des croyances
      set tick-of-K K-get "tick" ?
      if tick-of-K > K-get "tick" current-info-convoi
      [
        ;; Update
      ]
    ]
  ]
end


;; Retourne le champs voulu dans Info-Drones et Info-Convois
to-report K-get [field K]
    let pos position field K
    ;show (list "Timon HERE" pos field K)
    report item (pos + 1) K
end

to-report K-get-Info-Drone  [drone]
  let li (filter [member? drone ?]  intelligent-get-belief "K-Infos-Drones")
  ifelse empty? li
  [ report li ]
  [ report item 0 li ]
end

to-report K-get-Info-Convoi [convoi]
  let li filter [member? convoi ?] intelligent-get-belief "K-Infos-Convois"
  ifelse empty? li
  [ report li ]
  [ report item 0 li ]
end

;; Affiche un message seulement si le mode debug est actif
to show-debug [ msg ]
  if show_debug = true [ show msg ]
end