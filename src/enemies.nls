;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Enemies related code ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

breed [enemies enemy]

enemies-own [
  beliefs
  intentions
  munitions
  carburant
  vision-radius
  shoot-radius
  speed
  ;target ;belief; 
  max-dir
  my-path
  dead?
]


;;;;;;;;;;;
;; SETUP ;;
;;;;;;;;;;;

to setup-enemies
  
  ; Création des ennemis
  create-enemies nb-enemies
  
  ask enemies [
    ;; OWN VARIABLES
    
    ;; Statut de l'ennemi
    ;; ---
    ;; • munitons             :  Nombre de munitions que possède l'ennemi
    ;; • carburant            : Le drone suit le convoi
    ;; • vision-radius        : Le drone n'a plus assez de carburant
    ;; • shoot-radius         : Plus de fuel, ni de moyen de se ravitailler
    ;; • speed                : Vitesse de déplacement de l'ennemi
    ;; • max-dir              : Angle de rotation maximal par tour d'un ennemi
    ;; • my-path              : Plus de fuel, ni de moyen de se ravitailler
    ;; • dead?                : Plus de fuel, ni de moyen de se ravitailler
    
    ;; Variables pour BDI
    ;; ---
    ;; • beliefs              : Ensemble des croyances de l'ennemi
    ;; • intentions           : Ensemble des intentions de l'ennemi
    
    set munitions (average-munition-enemies - 5 + random 10) ;;
    set carburant (average-carburant-enemies - 5 + random 10)
    set vision-radius enemies-vision-radius
    set shoot-radius enemies-shoot-radius
    set speed 0.05 * simu-speed
    set max-dir 10 * simu-speed
    set my-path ([])
    set dead? false
    
    set beliefs ([])
    set intentions ([])
    
    ;; ASPECT
    set shape "truck"
    set color red - 2
    
    ;; PLACEMENT
    
    ; La moitié arrive du flanc nord
    ; L'autre arrive du flanc ouest
    ;    let tmp random 2
    ;    let randx random (max-pxcor / 10)
    ;    let randy random (max-pycor / 10)
    ;    move-to patch ((max-pxcor - randx) * tmp) ((max-pycor - randy)*(1 - tmp)) 1
    
    ; move-to one-of patches with [not obstacle? and not objectif? and not base? and not hangar?]
    move-to one-of patches with [not obstacle? and not objectif? and not base? and not hangar? and pxcor < (max-pxcor / 2) and pycor >= (max-pycor / 2) and pzcor = solAlt ]
    
    add-intention "attack-convois" "false"
  ]
end


;;;;;;;;;;
;; MOVE ;;
;;;;;;;;;;

; Mouvement randomisé, principalement pour le début de la simulation
to random-move-nowrap
  ;; Changement de cap selon probabilité
  if random 100 < 1 
  [ lt random max-dir * one-of [ 1 -1 ] ]
  
  ;; Vérification du patch en mire, si ce n'est pas un obstacle et s'il y en a un
  ifelse not (detect-obstacles-ahead)
    [
      fd speed
    ]
  ; sinon on tourne pour essayer de l'éviter
    [
      rt random max-dir
    ]
end

to move-to-patch [ patch-target ]
  rotate-enemy patch-target
  fd speed
  
end

to move-to-target-astar
  if not empty? my-path [
    let next-patch first my-path
    let zz pzcor
    set next-patch [patch-at 0 0 (zz - pzcor)] of next-patch ; mise a niveau de pzcor au cas ou le chemin a ete calculé sur un autre plan
                                                             ; Deplacement vers le prochain waypoint
    if next-patch != patch-here [move-to-patch next-patch]
    ; Si on a atteint ce patch, on le supprime de la liste, et on va donc continuer vers le prochain patch du chemin
    if patch-here = next-patch [
      set my-path remove-item 0 my-path
      if debug [ show (word "Waypoint atteint: " patch-here ", prochain: " next-patch ) ]
    ]
  ]
end

; Lorsqu'on a repéré un convoi, on fonce dessus pour lui tirer dessus
to move-to-target
  ifelse not empty? my-path
  [
    move-to-target-astar
  ]
  [
    rotate-enemy get-belief-enemy "target"
    
    ; On avance
    if distance get-belief-enemy "target" > enemies-shoot-radius / 3
    [
      fd speed
    ]
  ]
end

to move
  ifelse not exist-beliefs-of-type "target" [
    random-move-nowrap
  ]
  [
    move-to-target
  ]
end

to shoot-convois-in-range
  
end

;;;;;;;;;;;;;;;;;;;;;;;;
;; Fonctions diverses ;;
;;;;;;;;;;;;;;;;;;;;;;;;

to rotate-enemy [ goal ]
  ; Calcul de l'angle avec la cible
  let headingFlag (towards-nowrap goal)
  let dirCorrection subtract-headings headingFlag heading
  
  ; Arrondissement de l'angle (on ne veut pas faire de micro tournant)
  set dirCorrection precision dirCorrection 2
  
  ; Limite de l'angle, pour que ce soit plus realiste (l'ennemi ne peut pas faire un demi-tour sur place!)
  ifelse dirCorrection > max-dir [ ; limite a droite
    set dirCorrection max-dir
  ]
  [
    if dirCorrection < max-dir * -1 [ ; limite a gauche
      set dirCorrection max-dir * -1
    ]
  ]
  
  ; On tourne
  rt dirCorrection
end

; Détecte les obstacles entre la turtle et le patch où il doit se rendre devant lui
to-report detect-obstacles-ahead
  ; Vérification qu'on ne va pas dans le vide
  if abs (xcor - [pxcor] of patch-ahead speed) > speed + 5 or abs (ycor - [pycor] of patch-ahead speed) > speed + 5
  [ report true ]
  
  ; Vérification que le patch visé n'est pas un obstacle
  ; report [obstacle?] of patch-ahead speed
  
  ; Vérification que les patchs entre la turtle et le patch visé ne sont pas des obstacles
  let tmp 0
  let tmpbool false
  while [ tmp <= speed and tmpbool = false ]
  [
    set tmpbool [obstacle?] of patch-ahead tmp
    set tmp tmp + 0.05
  ]
  report tmpbool
end

to-report detect-obstacles-enemy-target
  ; on stocke le heading de la turtle pour la reset quand on a fini
  let headingFlag heading
  face-nowrap get-belief-enemy "target"
  
  ; Vérification que les patchs entre la turtle et le patch visé ne sont pas des obstacles
  let tmp 1
  let tmpbool false
  while [ tmp <= distance get-belief-enemy "target" and tmpbool = false ]
  [
    set tmpbool [obstacle?] of patch-ahead tmp
    set tmp tmp + 1
  ]
  
  set heading headingFlag
  report tmpbool
end

to detect-convois
  let targets convois in-radius-nowrap enemies-vision-radius
  ifelse count targets = 0 [
    if exist-beliefs-of-type "target"
    [
      remove-belief "target"
    ]
  ]
  [
    update-belief-enemy create-belief "target" (first sort-on [distance myself] targets)
  ]
end

; Decide d'un chemin a suivre si l'ennemi a une cible
to search-ways-for-enemies
  foreach sort-on [who] turtle-set enemies with [exist-beliefs-of-type "target" and not dead?] [
    let id ([who] of ?)
    let obstacle-ahead false
    ask enemy id [
      set obstacle-ahead detect-obstacles-enemy-target
    ]
    if obstacle-ahead and empty? [my-path] of ?
    and not [obstacle?] of [patch-here] of [get-belief-enemy "target"] of ? [ ; s'il n'y a pas encore de chemin du tout, ou pas de chemin pour cette voiture, on cree un plan AStar
                                                                              ; Cree le plan AStar (attention a ca que le patch start soit au niveau ou il y a les obstacles, ici pzcor = mapAlt pour les obstacles)
      let start-patch min-one-of (patches with [pzcor = mapAlt and not obstacle?]) [distance ?] ; on s'assure de choisir comme patch de depart un patch libre sans obstacle, sinon quand on split un convoi il se peut qu'il soit sur un obstacle et qu'il ne puisse jamais generer de chemin
      let tmp astar-longpath
      set astar-longpath false
      let path (plan-astar ([patch-at 0 0 (pzcor * -1)] of start-patch) [patch-here] of [get-belief-enemy "target"] of ? false)
      set astar-longpath tmp
      ask ? [ set my-path path ]
    ]
    if not obstacle-ahead [ ask ? [ set my-path [] ] ]
  ]
end

to enemies-think
  ;  ; Détection des convois à portée
  ;  ask enemies
  ;  [
  ;    detect-convois
  ;  ]
  
  ; Decide d'un chemin a suivre si l'ennemi a une cible
  search-ways-for-enemies
  
  ask enemies [
    execute-intentions
    ;    move
    ;    shoot-convois-in-range
  ]
end

to attack-convois
  detect-convois
  move
  shoot-convois-in-range
end

to update-belief-enemy [bel]
  ifelse exist-beliefs-of-type belief-type bel
    [
      update-belief bel
    ]
    [
      add-belief bel
    ]
end

to-report get-belief-enemy [b-type]
  report belief-content read-first-belief-of-type b-type
end
