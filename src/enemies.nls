breed [enemies enemy]

enemies-own [
  beliefs
  intentions
  munitions
  carburant
  vision-radius
  shoot-radius
  speed
  target
  max-dir
  my-path
  dead?
]

to setup-enemies
  create-enemies nb-enemies
  ask enemies [
    ;; OWN VARIABLES
    set munitions (average-munition-enemies - 5 + random 10)
    set carburant (average-carburant-enemies - 5 + random 10)
    set vision-radius enemies-vision-radius
    set shoot-radius enemies-shoot-radius
    set speed 0.05 * simu-speed
    set beliefs ([])
    set intentions ([])
    set target nobody
    set my-path ([])
    set dead? false
    
    ;; ASPECT
    set shape "truck"
    set color red - 2
    
    ;; PLACEMENT
    
    ; La moitié arrive du flanc nord
    ; L'autre arrive du flanc ouest
    ;    let tmp random 2
    ;    let randx random (max-pxcor / 10)
    ;    let randy random (max-pycor / 10)
    ;    move-to patch ((max-pxcor - randx) * tmp) ((max-pycor - randy)*(1 - tmp)) 1
    
    ; move-to one-of patches with [not obstacle? and not objectif? and not base? and not hangar?]
    move-to one-of patches with [not obstacle? and not objectif? and not base? and not hangar? and pxcor < (max-pxcor / 2) and pycor >= (max-pycor / 2) and pzcor = solAlt ]
  ]
end

to random-move
  if random 100 < 1 [ lt random 90 - 45 ]
  ifelse not [obstacle?] of patch-ahead speed [ 
    fd speed
  ]
  [
    rt random 90 - 45
  ]
end

to random-move-nowrap
  ;; Changement de cap
  if random 100 < 1 [ lt random 90 - 45 ]
  ;; Vérification du patch en mire
  ifelse not (detect-obstacles-ahead)
    and abs (xcor - [pxcor] of patch-ahead speed) < speed + 1
    and abs (ycor - [pycor] of patch-ahead speed) < speed + 1 [ 
    fd speed
  ]
  [
    rt random 90 - 45
  ]
end

to move-to-target
  face-nowrap target
  if distance target > enemies-shoot-radius / 2 and not [obstacle?] of patch-ahead speed [
    set color red - 2
    fd speed
    ;move-enemy patch-ahead speed
  ]
  if detect-obstacles-ahead
  [ set color blue
    move-to-target-astar target ]
end

to-report detect-obstacles-ahead
  report [obstacle?] of patch-ahead speed
end

to move-to-target-with-turn-speed
  move-enemy target
end

to detect-convois
  let targets convois in-radius-nowrap enemies-vision-radius
  ifelse count targets = 0 [
    set target nobody
  ]
  [
    set target first sort-on [distance myself] targets
  ]
end

to move
  ;if carburant > 0 [
  ifelse target = nobody [
;    random-move
    random-move-nowrap
  ]
  [
    move-to-target
;    move-to-target-astar target
  ]
  ;set carburant carburant - 1
end

to shoot-convois-in-range
  
end

to enemies-think  
  ; Decide d'un chemibn a suivre si l'ennemi a une cible
  search-ways-for-enemies
  
  ask enemies [
    detect-convois
    move
    shoot-convois-in-range
  ]
end

; TODO gerer le maxdir-enemy ?
to move-enemy [goal]
  let maxdir-enemy 45

  ; Calcule de l'angle avec la cible
  ;let headingFlag heading
  let headingFlag (towards-nowrap goal)
  let dirCorrection subtract-headings headingFlag heading
  
  ; Arrondissement de l'angle (on ne veut pas faire de micro tournant)
  set dirCorrection precision dirCorrection 2
  
  ; Limite de l'angle, pour que ce soit plus realiste (la voiture ne peut pas faire un demi-tour sur place!)
  ifelse dirCorrection > maxdir-enemy [ ; limite a droite
    set dirCorrection maxdir-enemy
  ]
  [
    if dirCorrection < maxdir-enemy * -1 [ ; limite a gauche
      set dirCorrection maxdir-enemy * -1
    ]
  ]

  ; On tourne
  rt dirCorrection

  ; Deplacement
  set pitch 0 ; make sure there's no pitch ever, else the car will disappear in the ground
  fd speed ; Avance
end


to move-to-target-astar [goal]
  if not empty? my-path [
    let next-patch first my-path
    let zz pzcor
    set next-patch [patch-at 0 0 (zz - pzcor)] of next-patch ; mise a niveau de pzcor au cas ou le chemin a ete calculé sur un autre plan
                                                             ; Deplacement vers le prochain waypoint
    if next-patch != patch-here [move-enemy next-patch]
    ; Si on a atteint ce patch, on le supprime de la liste, et on va donc continuer vers le prochain patch du chemin
    if patch-here = next-patch [
      set my-path remove-item 0 my-path
      if debug [ show (word "Waypoint atteint: " patch-here ", prochain: " next-patch ) ]
    ]
  ]
end

; Decide d'un chemibn a suivre si l'ennemi a une cible
to search-ways-for-enemies
  foreach sort-on [who] turtle-set enemies with [target != nobody and not dead? and detect-obstacles-ahead] [
    let id ([who] of ?)
    if empty? [my-path] of ? [ ; s'il n'y a pas encore de chemin du tout, ou pas de chemin pour cette voiture, on cree un plan AStar
                               ; Cree le plan AStar (attention a ca que le patch start soit au niveau ou il y a les obstacles, ici pzcor = mapAlt pour les obstacles)
      let start-patch min-one-of (patches with [pzcor = mapAlt and not obstacle?]) [distance ?] ; on s'assure de choisir comme patch de depart un patch libre sans obstacle, sinon quand on split un convoi il se peut qu'il soit sur un obstacle et qu'il ne puisse jamais generer de chemin
      let tmp astar-longpath
      set astar-longpath false
      let path (plan-astar ([patch-at 0 0 (pzcor * -1)] of start-patch) [patch-here] of [target] of ? false)
      set astar-longpath tmp
      ask ? [ set my-path path ]
    ]
  ]
end
